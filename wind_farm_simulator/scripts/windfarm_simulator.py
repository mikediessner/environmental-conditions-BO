import torch
import numpy as np
from py_wake.examples.data.ParqueFicticio import ParqueFicticioSite
from py_wake.examples.data.hornsrev1 import V80
from py_wake.wind_farm_models.engineering_models import PropagateDownwind
from py_wake.deficit_models.gaussian import BastankhahGaussianDeficit
from py_wake.superposition_models import SquaredSum
from py_wake.wind_turbines import WindTurbine
from py_wake.site import Site
from py_wake.wind_farm_models.wind_farm_model import SimulationResult
from py_wake.deficit_models.deficit_model import ConvectionDeficitModel
from numpy import newaxis as na

from typing import Tuple


MIN_X = 262878
MAX_X = 264778
MIN_Y = 6504714
MAX_Y = 6506614
SPACING = 160


def simulate_aep(params: torch.Tensor | np.ndarray) -> float:
    """
    Returns the amount of energy generated by the whole windfarm.

    Parameters
    ----------
    params : ``torch.Tensor`` or ``np.ndarray``
        Controllable and environmental parameters in order:
        - X locations of wind turbines,
        - Y locations of wind turbines,
        - wind direction,
        - wind speed.

    Returns
    -------
    float
        Annual energy production of wind farm in GWh.
    """

    if not isinstance(params, list):
        params = params.reshape(-1)
    
    n_env_params = 2
    n_control_params = len(params) - n_env_params
    wt_x = params[:int(n_control_params/2)]
    wt_y = params[int(n_control_params/2):n_control_params]
    wd = params[-2]
    ws = params[-1]

    site = ParqueFicticioSite()
    wind_turbines = V80()
    wf_model = Bastankhah_PorteAgel_2014(site, wind_turbines, groundModel=None)
    sim_res = wf_model(wt_x, wt_y,  # Wind turbine positions
                       h=None,      # Wind turbine heights
                       type=0,      # Wind turbine types
                       wd=wd,       # Wind direction
                       ws=ws,       # Wind speed
                       )

    return sim_res.aep().sum().values


def simulate(wt_x, wt_y, wd, ws) -> Tuple[SimulationResult, Site, WindTurbine]:
    """
    Returns the simulaion results from PyWake as well as the used site and wind
    turbine.

    Parameters
    ----------
    wt_x :
        X locations of wind turbines. Controllable variable.
    wt_y : 
        Y locations of wind turbines. Controllable variable.
    wd :
        Wind direction. Environmental variable.
    ws :
        Wind speed. Environmental variable.

    Returns
    -------
    sim_res : ``SimulationResult``
        Results of wind farm simulation.
    site : ``Site``
        Site of wind farm simulation.
    wind_trubines : ``WindTurbine``
        Wind turbines used in simulation.
    """

    site = ParqueFicticioSite()
    wind_turbines = V80()
    wf_model = Bastankhah_PorteAgel_2014(site, wind_turbines, groundModel=None)
    sim_res = wf_model(wt_x, wt_y, # Wind turbine positions
                       h=70,       # Wind turbine heights
                       type=0,     # Wind turbine types
                       wd=wd,      # Wind direction
                       ws=ws,      # Wind speed
                       )
    
    return sim_res, site, wind_turbines


def ct2a_madsen(ct, ct2ap=np.array([0.2460, 0.0586, 0.0883])):
    """
    BEM axial induction approximation by

    Madsen, H. A., Larsen, T. J., Pirrung, G. R., Li, A., and Zahle, F.:
    Implementation of the blade element momentum model on a polar grid and its
    aeroelastic load impact, Wind Energ. Sci., 5, 1–27,
    https://doi.org/10.5194/wes-5-1-2020, 2020.

    Source: https://github.com/DTUWindEnergy/PyWake/blob/master/py_wake/deficit_models/utils.py
    """
    # Evaluate with Horner's rule.
    # ct2a_ilk = ct2ap[2] * ct_ilk**3 + ct2ap[1] * ct_ilk**2 + ct2ap[0] * ct_ilk
    return ct * (ct2ap[0] + ct * (ct2ap[1] + ct * ct2ap[2]))


class Bastankhah_PorteAgel_2014(PropagateDownwind):
    """
    Implemented according to:
        Bastankhah M and Porté-Agel F.
        A new analytical model for wind-turbine wakes.
        J. Renew. Energy. 2014;70:116-23.

    Description:
        - Conservation of mass and momentum is applied with the assumption of a
        Gaussian shape for the wake profile in the calculation of the wake
        deficit.
        - Only one parameter needed to determine the velocity distribution: the
        wake expansion parameter k.

    Source: https://github.com/DTUWindEnergy/PyWake/blob/master/py_wake/literature/gaussian_models.py
    """

    def __init__(self, site, windTurbines, k=0.0324555, ceps=.2, ct2a=ct2a_madsen, use_effective_ws=False,
                 rotorAvgModel=None, superpositionModel=SquaredSum(),
                 deflectionModel=None, turbulenceModel=None, groundModel=None):
        """
        Parameters
        ----------
        site : Site
            Site object
        windTurbines : WindTurbines
            WindTurbines object representing the wake generating wind turbines
        k : float
            Wake expansion factor
        use_effective_ws : bool
            Option to use either the local (True) or free-stream wind speed
            (False) experienced by the ith turbine
        rotorAvgModel : RotorAvgModel, optional
            Model defining one or more points at the down stream rotors to
            calculate the rotor average wind speeds from.\n
            if None, default, the wind speed at the rotor center is used
        superpositionModel : SuperpositionModel, default SquaredSum
            Model defining how deficits sum up
        deflectionModel : DeflectionModel, default None
            Model describing the deflection of the wake due to yaw misalignment,
            sheared inflow, etc.
        turbulenceModel : TurbulenceModel, default None
            Model describing the amount of added turbulence in the wake
        """
        PropagateDownwind.__init__(self, site, windTurbines,
                                   wake_deficitModel=BastankhahGaussianDeficit(ct2a=ct2a, k=k, ceps=ceps,
                                                                               use_effective_ws=use_effective_ws,
                                                                               rotorAvgModel=rotorAvgModel,
                                                                               groundModel=groundModel),
                                   superpositionModel=superpositionModel, deflectionModel=deflectionModel,
                                   turbulenceModel=turbulenceModel)


class BastankhahGaussianDeficit(ConvectionDeficitModel):
    """
    Implemented according to
    Bastankhah M and Porté-Agel F. A new analytical model for wind-turbine
    wakes. J. Renew. Energy. 2014;70:116-23.

    Source: https://github.com/DTUWindEnergy/PyWake/blob/master/py_wake/deficit_models/gaussian.py
    """

    def __init__(self, ct2a=ct2a_madsen, k=0.0324555, ceps=.2,
                 use_effective_ws=False, rotorAvgModel=None, groundModel=None):
        ConvectionDeficitModel.__init__(self, rotorAvgModel=rotorAvgModel, groundModel=groundModel,
                                        use_effective_ws=use_effective_ws)
        self._k = k
        self._ceps = ceps
        self.ct2a = ct2a

    def k_ilk(self, **kwargs):
        return np.array([[[self._k]]])

    def epsilon_ilk(self, ct_ilk, **_):
        # not valid for CT >= 1.
        sqrt1ct_ilk = np.sqrt(1 - np.minimum(0.999, ct_ilk))
        beta_ilk = 1 / 2 * (1 + sqrt1ct_ilk) / sqrt1ct_ilk

        return self._ceps * np.sqrt(beta_ilk)

    def sigma_ijlk(self, D_src_il, dw_ijlk, ct_ilk, **kwargs):
        # dimensional wake expansion
        return self.k_ilk(**kwargs)[:, na] * dw_ijlk + \
            self.epsilon_ilk(ct_ilk)[:, na] * D_src_il[:, na, :, na]

    def ct_func(self, ct_ilk, **_):
        return ct_ilk[:, na]

    def _calc_deficit(self, D_src_il, dw_ijlk, ct_ilk, **kwargs):
        if self.WS_key == 'WS_jlk':
            WS_ref_ijlk = kwargs[self.WS_key][na]
        else:
            WS_ref_ijlk = kwargs[self.WS_key][:, na]

        # dimensional wake expansion
        sigma_sqr_ijlk = (self.sigma_ijlk(D_src_il=D_src_il, dw_ijlk=dw_ijlk, ct_ilk=ct_ilk, **kwargs))**2

        ctx_ijlk = self.ct_func(ct_ilk=ct_ilk, dw_ijlk=dw_ijlk, D_src_il=D_src_il)
        deficit_centre_ijlk = WS_ref_ijlk * np.minimum(1,
                                                       2. * self.ct2a(ctx_ijlk * D_src_il[:, na, :, na]**2 /
                                                                      (8. * sigma_sqr_ijlk)))

        return WS_ref_ijlk, sigma_sqr_ijlk, deficit_centre_ijlk, ctx_ijlk

    def calc_deficit(self, D_src_il, dw_ijlk, cw_ijlk, ct_ilk, **kwargs):
        _, sigma_sqr_ijlk, deficit_centre_ijlk, _ = self._calc_deficit(D_src_il, dw_ijlk, ct_ilk, **kwargs)

        # term inside exp()
        exponent_ijlk = -1 / (2 * sigma_sqr_ijlk) * cw_ijlk**2

        # Point deficit
        deficit_ijlk = deficit_centre_ijlk * np.exp(exponent_ijlk)
        return deficit_ijlk

    def wake_radius(self, D_src_il, dw_ijlk, ct_ilk, **kwargs):
        # according to Niayifar, the wake radius is twice sigma
        sigma_ijlk = self.sigma_ijlk(D_src_il=D_src_il, dw_ijlk=dw_ijlk, ct_ilk=ct_ilk, **kwargs)
        return 2. * sigma_ijlk

    def calc_deficit_convection(self, D_src_il, dw_ijlk, cw_ijlk, ct_ilk, **kwargs):
        if self.groundModel:
            raise NotImplementedError(
                "calc_deficit_convection (WeightedSum) cannot be used in combination with GroundModels")
        WS_ref_ijlk, sigma_sqr_ijlk, deficit_centre_ijlk, ctx_ijlk = self._calc_deficit(
            D_src_il, dw_ijlk, ct_ilk, **kwargs)
        # Convection velocity
        uc_ijlk = WS_ref_ijlk * (1. - self.ct2a(ctx_ijlk * D_src_il[:, na, :, na]**2 / (8. * sigma_sqr_ijlk)))
        sigma_sqr_ijlk = np.broadcast_to(sigma_sqr_ijlk, deficit_centre_ijlk.shape)

        return deficit_centre_ijlk, uc_ijlk, sigma_sqr_ijlk
